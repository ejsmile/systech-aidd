# Frontend Tech Stack

> **Базовый документ:** [front-vision.md](./front-vision.md)

## Обзор

Выбранный технологический стек для frontend приложения основан на современных, проверенных технологиях с фокусом на простоту, производительность и Developer Experience.

## Основной стек

### React 18 + TypeScript

**Выбор:** React 18.2+ с TypeScript 5+

**Обоснование:**
- **Популярность** - самый популярный frontend фреймворк, огромное сообщество
- **Type Safety** - TypeScript обеспечивает проверку типов на этапе разработки
- **Современные возможности** - Concurrent Rendering, Automatic Batching, Transitions
- **Богатая экосистема** - множество готовых библиотек и инструментов
- **Опыт команды** - знакомая технология для разработчиков

**Альтернативы рассмотренные:**
- Vue.js - хорошая альтернатива, но меньше опыта в команде
- Svelte - интересная технология, но меньше библиотек и меньше популярность

### Vite

**Выбор:** Vite 5+

**Обоснование:**
- **Скорость разработки** - мгновенный холодный старт, быстрый HMR
- **Простая конфигурация** - минимальная настройка out-of-the-box
- **Современные стандарты** - нативная поддержка ES modules
- **Оптимизация production** - использует Rollup для оптимальной сборки
- **TypeScript поддержка** - встроенная поддержка без дополнительных плагинов

**Альтернативы рассмотренные:**
- Create React App - устарел, медленный, много лишнего
- Next.js - overkill для нашего случая (не нужен SSR)
- Webpack - сложнее в настройке, медленнее

## UI & Styling

### Shadcn/ui

**Выбор:** Shadcn/ui (Radix UI + Tailwind CSS)

**Обоснование:**
- **Не библиотека, а коллекция** - компоненты копируются в проект, полный контроль
- **Настраиваемость** - легко кастомизировать под свои нужды
- **Современный дизайн** - актуальные UI паттерны
- **Accessibility** - built-in ARIA атрибуты через Radix UI
- **TypeScript** - полная типизация из коробки
- **Tailwind CSS** - utility-first подход, быстрая разработка

**Альтернативы рассмотренные:**
- Chakra UI - хорошая библиотека, но менее гибкая кастомизация
- Material UI - тяжелая, специфичный Material Design стиль
- Ant Design - слишком корпоративный дизайн

### Tailwind CSS

**Выбор:** Tailwind CSS 3+

**Обоснование:**
- **Utility-First** - быстрая разработка через утилитарные классы
- **Consistency** - единый дизайн-язык через конфигурацию
- **Tree-shaking** - неиспользуемые стили не попадают в bundle
- **Responsive** - простые breakpoints для адаптивности
- **Dark mode** - легкая поддержка темной темы (будущее расширение)

## Визуализация данных

### Recharts

**Выбор:** Recharts 2+

**Обоснование:**
- **Декларативный API** - React-native подход к созданию графиков
- **Простота использования** - минимум кода для базовых графиков
- **Кастомизация** - гибкие возможности настройки
- **Responsive** - автоматическая адаптация под размер контейнера
- **TypeScript поддержка** - типизация из коробки
- **Достаточность** - покрывает все наши требования (line charts, bar charts)

**Альтернативы рассмотренные:**
- Chart.js - более императивный подход, менее React-friendly
- D3.js - слишком low-level для наших задач, overkill
- Victory - хорошая альтернатива, но менее популярна

## Routing

### React Router

**Выбор:** React Router 6+

**Обоснование:**
- **Стандарт индустрии** - de-facto стандартная библиотека для роутинга в React
- **Декларативность** - роуты объявляются как компоненты
- **Lazy Loading** - поддержка code splitting
- **TypeScript** - полная типизация
- **Простота** - для нашего случая (2 страницы) более чем достаточно

**Альтернативы рассмотренные:**
- TanStack Router - новая библиотека, еще не устоялась
- Wouter - слишком минималистична

## State Management

### React Context API

**Выбор:** Встроенный React Context API + useState/useReducer

**Обоснование:**
- **KISS принцип** - не добавляем лишних зависимостей
- **Встроенное решение** - часть React, нет external dependencies
- **Достаточность** - для нашего простого state более чем достаточно
- **Type Safety** - легко типизировать через TypeScript
- **Learning Curve** - нет необходимости учить новую библиотеку

**Что храним в state:**
- Данные статистики (Dashboard)
- История сообщений чата (Chat)
- UI состояния (loading, errors)

**Альтернативы рассмотренные:**
- Redux Toolkit - overkill для простого приложения
- Zustand - хорошая библиотека, но пока не нужна
- Jotai/Recoil - atomic state, слишком сложно для наших задач

## HTTP Client

### Fetch API

**Выбор:** Нативный fetch API

**Обоснование:**
- **Встроенный** - нет дополнительных зависимостей
- **Современный** - поддерживается всеми современными браузерами
- **Promises/Async-Await** - удобная работа с асинхронностью
- **Достаточность** - для простых REST API запросов более чем достаточно
- **TypeScript** - встроенные типы

**Обертка:** Создадим простую обертку для базового URL и error handling

**Альтернативы рассмотренные:**
- Axios - хорошая библиотека, но добавляет лишний вес в bundle
- TanStack Query - мощная библиотека, но overkill для наших задач (пока)

## Testing

### Vitest + React Testing Library

**Выбор:** Vitest 1+ для unit тестов, React Testing Library для компонентов

**Обоснование:**
- **Vitest** - быстрый, совместимый с Vite, Jest-like API
- **React Testing Library** - тестирование с точки зрения пользователя
- **TypeScript** - встроенная поддержка
- **Performance** - быстрое выполнение тестов
- **Developer Experience** - hot reload для тестов

**Coverage цель:** > 70% для критичных компонентов

**Альтернативы рассмотренные:**
- Jest - более медленный, требует дополнительной настройки с Vite
- Cypress/Playwright - для E2E тестов (на данный момент не требуется)

## Code Quality

### ESLint + Prettier

**Выбор:** ESLint 8+ с React плагинами, Prettier 3+

**Обоснование:**
- **ESLint** - линтинг для выявления проблем в коде
- **Prettier** - автоформатирование для consistency
- **React плагины** - специфичные правила для React (hooks, jsx)
- **TypeScript ESLint** - правила для TypeScript кода
- **Интеграция** - работают вместе без конфликтов

**Правила:**
- React Hooks правила
- TypeScript strict правила
- Import sorting
- Prettier интеграция

## Дополнительные инструменты

### Development

- **React DevTools** - отладка React компонентов
- **Vite DevTools** - отладка сборки (если понадобится)

### Git Hooks (будущее)

- **Husky** - pre-commit hooks
- **lint-staged** - линтинг только измененных файлов

## Структура зависимостей

### Production Dependencies

```json
{
  "react": "^18.2.0",
  "react-dom": "^18.2.0",
  "react-router-dom": "^6.20.0",
  "recharts": "^2.10.0"
}
```

### Development Dependencies

```json
{
  "typescript": "^5.3.0",
  "vite": "^5.0.0",
  "@vitejs/plugin-react": "^4.2.0",
  "tailwindcss": "^3.4.0",
  "autoprefixer": "^10.4.0",
  "postcss": "^8.4.0",
  "eslint": "^8.55.0",
  "eslint-plugin-react": "^7.33.0",
  "eslint-plugin-react-hooks": "^4.6.0",
  "@typescript-eslint/eslint-plugin": "^6.15.0",
  "@typescript-eslint/parser": "^6.15.0",
  "prettier": "^3.1.0",
  "vitest": "^1.0.0",
  "@testing-library/react": "^14.1.0",
  "@testing-library/jest-dom": "^6.1.0",
  "@testing-library/user-event": "^14.5.0",
  "jsdom": "^23.0.0"
}
```

## Принципы выбора

### KISS (Keep It Simple)

Каждая выбранная технология должна:
1. Решать конкретную проблему
2. Быть простой в использовании
3. Не добавлять излишней сложности

### Developer Experience

Приоритет на:
1. Быструю разработку
2. Хорошую документацию
3. Type safety
4. Отладку и тестирование

### Performance

Фокус на:
1. Минимальный bundle size
2. Быструю загрузку
3. Оптимизированный runtime

### Maintainability

Важно:
1. Активное сообщество
2. Регулярные обновления
3. Долгосрочная поддержка

---

**Версия:** 1.0  
**Дата:** 2025-10-17  
**Статус:** Утверждено

