---
alwaysApply: false
---
# Workflow работы с техническим долгом

> **Базовые документы:** @tasklist_tech_dept.md, @conventions.mdc, @vision.md

## Цикл работы по итерации технического долга

### 1. Подготовка

#### Анализ итерации
- Прочитать текущую итерацию из @tasklist_tech_dept.md {input0}
- Проверить все задачи и требования
- Изучить секцию "Проверка соответствия" в итерации
- Изучить релевантные части @conventions.mdc и @vision.md

#### Проверка текущего состояния
- Запустить `make quality` для оценки текущего состояния кода
- Запустить `make test` (если тесты уже есть)
- Зафиксировать baseline для сравнения после изменений

### 2. Согласование решения

**ДО начала реализации:**

#### Структура согласования
- Предложить конкретное решение для каждой задачи
- Показать **ключевые отрезки кода** для каждого файла
- Указать структуру классов/функций с **type hints**
- Показать примеры использования новых типов/классов

#### Проверка требований к качеству
- Убедиться, что решение следует принципу **KISS** (@conventions.mdc)
- Проверить соответствие принципу **1 класс = 1 файл**
- Подтвердить использование **async/await** где необходимо
- Убедиться в наличии **type hints везде** (mypy strict mode)

#### Согласование с разработчиком
- Дождаться **явного подтверждения** плана
- Получить feedback по предложенному решению
- **НЕ начинать** реализацию без подтверждения

### 3. Реализация

**ПОСЛЕ согласования:**

#### Создание/изменение кода
- Создать/изменить файлы согласно плану
- Следовать принципу **KISS** - максимально простые решения
- Следовать принципу **1 класс = 1 файл**
- Использовать `async/await` везде, где нужна асинхронность

#### Требования к коду
- **Type hints везде** - для всех функций, методов, атрибутов
- Использовать `Literal` для строгой типизации строковых констант
- Использовать `Enum` для валидации значений с именами
- Современный синтаксис Python 3.11+: `list[str]`, `dict[str, int]`

#### Документирование
- Docstrings только для неочевидной логики
- Комментарии только для объяснения "почему", а не "что"
- Самодокументируемые имена классов, методов, переменных

#### Организация импортов
Следовать стандартной структуре:
```python
# 1. Стандартная библиотека
import logging
from dataclasses import dataclass

# 2. Сторонние библиотеки
from aiogram import Bot, Dispatcher
from pydantic import BaseModel

# 3. Локальные импорты
from .config import Config
from .models import ChatMessage
```

### 4. Проверка качества кода

**Обязательные проверки после реализации:**

#### Автоматические проверки
```bash
# 1. Форматирование
make format

# 2. Линтер
make lint

# 3. Type checker
make typecheck

# 4. Все проверки вместе
make quality
```

**Все проверки должны проходить без ошибок.**

#### Проверка type hints
- Запустить `make typecheck` отдельно
- Убедиться, что нет type errors
- Проверить, что все функции имеют аннотации параметров и return type
- Проверить, что все методы классов имеют аннотации
- Проверить, что все атрибуты классов имеют type hints

#### Специфичные проверки для итерации
- Выполнить все пункты из секции "Проверка соответствия" в @tasklist_tech_dept.md
- Проверить соответствие принципам из @conventions.mdc
- Проверить соответствие архитектуре из @vision.md

### 5. Тестирование

#### Виртуальное окружение
**ОБЯЗАТЕЛЬНО:** Все команды выполняются ТОЛЬКО в виртуальном окружении.

```bash
# Активация (если еще не активировано)
source .venv/bin/activate  # macOS/Linux
# или
.venv\Scripts\activate     # Windows
```

#### Выполнение тестов
- Выполнить тестирование из раздела "Тест" итерации
- Запустить `make test` - все тесты должны проходить
- Запустить `make test-cov` для проверки coverage (если требуется)
- Убедиться, что coverage соответствует требованиям итерации

#### Функциональное тестирование
- Выполнить сценарии из раздела "Тест" итерации
- Проверить работу бота (если применимо): `make run`
- Убедиться, что код работает как ожидается
- **Дождаться подтверждения** от разработчика

### 6. Финальная проверка соответствия

**Перед коммитом проверить все пункты:**

#### Соответствие @conventions.mdc
- [x] ✅ Код следует принципу KISS
- [x] ✅ Правило "1 класс = 1 файл" соблюдено
- [x] ✅ Все async/await на месте
- [x] ✅ Правильная структура импортов
- [x] ✅ Type hints для всех классов, методов и функций
- [x] ✅ Использование Literal/Enum где необходимо
- [x] ✅ Логирование соответствует уровням

#### Соответствие @vision.md
- [x] ✅ Не отклоняемся от общей архитектуры
- [x] ✅ Используем правильные библиотеки из стека
- [x] ✅ Следуем паттернам кода

#### Соответствие итерации
- [x] ✅ Все задачи из секции "Задачи" выполнены
- [x] ✅ Все пункты из "Проверка соответствия" пройдены
- [x] ✅ Все тесты из секции "Тест" успешны

#### Проверки качества
- [x] ✅ `make quality` проходит без ошибок
- [x] ✅ `make test` проходит без ошибок (если применимо)
- [x] ✅ `make typecheck` проходит без ошибок

### 7. Фиксация прогресса

#### Обновление документации
- Отметить выполненные задачи в @tasklist_tech_dept.md (✅)
- Обновить статус итерации в таблице прогресса:
  - Статус: ⏳ → ✅
  - Проверка качества: указать результаты
  - Дата завершения: текущая дата
- Обновить coverage метрики (если применимо)

### 8. Коммит

#### Формат сообщения коммита
```bash
feat: tech debt iteration X - [краткое описание]

- Задача 1
- Задача 2
- Задача 3

Quality checks:
- format: ✅
- lint: ✅
- typecheck: ✅
- tests: ✅ (X passed)
- coverage: XX%

Ref: @tasklist_tech_dept.md iteration X
```

#### Выполнение коммита
- Убедиться, что все файлы добавлены в stage
- Сделать коммит с понятным сообщением
- **НЕ делать** force push
- **НЕ пропускать** hooks (--no-verify)

### 9. Переход к следующей итерации

#### Подведение итогов
- Показать summary выполненной работы
- Указать улучшения метрик (coverage, type safety, etc.)
- Отметить любые проблемы или технические долги

#### Согласование следующего шага
- Согласовать с разработчиком переход к следующей итерации
- **НЕ начинать** новую итерацию без подтверждения
- Дождаться явного "переходим к итерации X"

---

## Виртуальное окружение

### Обязательное требование
**Все команды, тесты и запуски проекта выполняются ТОЛЬКО в виртуальном окружении.**

### Работа с uv

#### Создание виртуального окружения
```bash
uv venv
```

#### Активация виртуального окружения
```bash
# macOS/Linux
source .venv/bin/activate

# Windows
.venv\Scripts\activate
```

#### Установка зависимостей
```bash
# После активации виртуального окружения
uv pip install -e .

# Установка dev-зависимостей (для технического долга)
uv pip install -e ".[dev]"
```

#### Запуск команд
```bash
# Все команды выполняются в активированном окружении
uv run python -m src.main
uv run pytest
uv run ruff check .
uv run mypy src/
```

### Правила
- ✅ Всегда активируй виртуальное окружение перед работой
- ✅ Используй `uv run` для запуска команд
- ✅ Устанавливай зависимости через `uv pip install`
- ❌ НЕ устанавливай пакеты глобально
- ❌ НЕ запускай команды вне виртуального окружения

---

## Инструменты качества кода

### Обязательные инструменты

#### ruff - форматирование и линтинг
```bash
# Автоформатирование
make format

# Проверка и автоисправление
make lint
```

**Настройки:** `[tool.ruff]` в pyproject.toml
- Длина строки: 100 символов
- Target version: Python 3.11+
- Select правила: E, F, I, N, W, UP, B, C90, PL

#### mypy - проверка типов
```bash
# Проверка типов
make typecheck
```

**Настройки:** `[tool.mypy]` в pyproject.toml
- Strict mode: включен
- Требует type hints для всех функций/методов
- Проверяет корректность типов

#### pytest - тестирование
```bash
# Запуск тестов
make test

# Тесты с coverage
make test-cov
```

**Настройки:** `[tool.pytest.ini_options]` в pyproject.toml
- Async mode: auto
- Test paths: tests/
- Coverage target: > 70% для критичных модулей

### Команды проверки

```bash
make format      # Автоформатирование кода (ruff format)
make lint        # Проверка линтером (ruff check --fix)
make typecheck   # Проверка типов (mypy src/)
make quality     # Все проверки вместе (format + lint + typecheck)
make test        # Запуск тестов (pytest)
make test-cov    # Тесты с coverage отчетом
```

**Важно:** `make quality` должен проходить без ошибок перед каждым коммитом.

---

## Правила работы с техническим долгом

### ✅ Делать

**Перед началом:**
- Внимательно читать описание итерации
- Проверять baseline (`make quality`, `make test`)
- Согласовывать решение ПЕРЕД реализацией с деталями и примерами кода
- Ждать явного подтверждения от разработчика

**Во время работы:**
- Работать строго по плану итерации
- Следовать всем требованиям из @conventions.mdc
- Добавлять type hints везде (mypy strict mode)
- Проверять соответствие каждому пункту "Проверка соответствия"

**После реализации:**
- Запускать `make quality` - должно проходить без ошибок
- Запускать `make test` - все тесты должны проходить
- Выполнять все тесты из секции "Тест" итерации
- Ждать подтверждения ПОСЛЕ реализации

**При завершении:**
- Обновлять @tasklist_tech_dept.md
- Делать коммиты с указанием результатов проверок
- Согласовывать переход к следующей итерации

### ❌ НЕ делать

**Запрещено:**
- Начинать реализацию без согласования
- Переходить к следующей задаче без подтверждения
- Делать несколько итераций за раз
- Отклоняться от @conventions.mdc и @vision.md
- Усложнять решения (анти-KISS)
- Коммитить код с ошибками `make quality`
- Пропускать проверки соответствия
- Игнорировать type hints warnings от mypy

**Избегать:**
- Сложных абстракций без явной необходимости
- Избыточного тестирования на старте (следовать плану)
- Изменения нескольких классов в одном файле
- Использования устаревших практик библиотек

---

## Шаблон согласования для технического долга

```markdown
### Итерация X: [Название]

**Цель:** [Краткое описание цели итерации]

**План реализации:**

1. Файл: `src/example.py`
   ```python
   # Imports
   import logging
   from dataclasses import dataclass
   from typing import Literal
   
   logger = logging.getLogger(__name__)
   
   # Class with type hints
   @dataclass(frozen=True)
   class Example:
       field1: str
       field2: int
       
       def __init__(self, param1: str, param2: int) -> None:
           ...
       
       async def method(self, arg: str) -> str:
           """Docstring если логика неочевидна"""
           ...
   ```

2. Файл: `pyproject.toml` (если нужны изменения)
   ```toml
   [tool.ruff]
   line-length = 100
   
   [tool.mypy]
   strict = true
   ```

3. Файл: `Makefile` (если нужны новые команды)
   ```makefile
   target:
       uv run command
   ```

**Изменения в существующих файлах:**

1. `src/existing.py`
   - Изменение 1: [описание]
   - Изменение 2: [описание]

**Проверка соответствия:**
- [ ] ✅ Код следует KISS принципу
- [ ] ✅ Правило "1 класс = 1 файл" соблюдено
- [ ] ✅ Type hints везде (mypy strict)
- [ ] ✅ Async/await используется правильно
- [ ] ✅ [Специфичные для итерации проверки]

**Ожидаемый результат:**
- `make quality` проходит без ошибок
- [Другие ожидаемые результаты из итерации]

**Готов к реализации?**
```

---

## Шаблон коммита для технического долга

```bash
feat: tech debt iteration X - [краткое описание итерации]

Changes:
- Задача 1: [детали]
- Задача 2: [детали]
- Задача 3: [детали]

Quality checks:
- format: ✅ (ruff format passed)
- lint: ✅ (ruff check passed)
- typecheck: ✅ (mypy strict mode passed)
- tests: ✅ (X tests passed)
- coverage: XX% (target: YY%)

Compliance:
- ✅ KISS principle (@conventions.mdc)
- ✅ 1 class = 1 file (@conventions.mdc)
- ✅ Type hints everywhere (mypy strict)
- ✅ All iteration checks passed

Ref: @tasklist_tech_dept.md iteration X
```

---

## Специфические проверки для итераций

### Итерация 1: Инструменты качества кода
- Все инструменты установлены: ruff, mypy, pytest
- Конфигурация в pyproject.toml корректна
- Makefile команды работают
- `make quality` проходит без ошибок
- Type hints добавлены для всех функций/методов/атрибутов

### Итерация 2: Рефакторинг моделей данных
- Конфликт имен устранен (ChatMessage vs aiogram Message)
- Literal используется для role
- Enum используется где необходимо
- Все импорты обновлены
- Workaround'ы удалены
- Docstrings добавлены для неочевидной логики

### Итерация 3: Структура тестирования
- Директория tests/ создана
- conftest.py с fixtures
- pytest настроен в pyproject.toml
- Coverage настроен
- Makefile команды для тестирования работают
- Примеры тестов проходят

### Итерация 4: Базовые unit-тесты
- Тесты для критичных компонентов
- Mock'и только для внешних API
- Понятные названия тестов
- Coverage > 70% для критичных модулей
- Все тесты изолированы и быстры

### Итерация 5: Интеграционные тесты
- Покрытие критичных сценариев
- Тесты полного цикла работы
- Тесты конфигурации (fail-fast)
- Coverage > 80% для критичных модулей
- `make quality && make test-cov` проходит полностью

---

## Контрольный чеклист перед коммитом

**Обязательно проверить:**

### Автоматические проверки
- [ ] ✅ `make format` выполнен (код отформатирован)
- [ ] ✅ `make lint` проходит (нет ошибок линтера)
- [ ] ✅ `make typecheck` проходит (нет type errors)
- [ ] ✅ `make quality` проходит полностью
- [ ] ✅ `make test` проходит (если тесты есть)

### Соответствие conventions
- [ ] ✅ Код следует KISS принципу
- [ ] ✅ 1 класс = 1 файл соблюдено
- [ ] ✅ Type hints везде (все функции/методы/атрибуты)
- [ ] ✅ Async/await используется правильно
- [ ] ✅ Импорты организованы правильно (stdlib → 3rd party → local)
- [ ] ✅ Логирование соответствует уровням

### Соответствие итерации
- [ ] ✅ Все задачи из "Задачи" выполнены
- [ ] ✅ Все пункты "Проверка соответствия" пройдены
- [ ] ✅ Все тесты из "Тест" успешны
- [ ] ✅ Таблица прогресса обновлена

### Документация
- [ ] ✅ @tasklist_tech_dept.md обновлен
- [ ] ✅ Статус итерации изменен на ✅
- [ ] ✅ Дата завершения указана
- [ ] ✅ Результаты проверок записаны

---

## Приоритеты итераций

### 🔥 Критично
**Итерация 1:** Инструменты качества кода
- Блокирует все остальные итерации
- Необходима для автоматизации проверок
- Требует установки dev-зависимостей

**Итерация 2:** Рефакторинг моделей данных
- Устраняет технические проблемы
- Улучшает type safety
- Подготавливает код для тестирования

### ⚡ Важно
**Итерация 3:** Структура тестирования
- Создает основу для тестов
- Настраивает инструменты (pytest, coverage)
- Необходима для следующих итераций

**Итерация 4:** Базовые unit-тесты
- Покрывает критичные компоненты
- Обеспечивает > 70% coverage
- Предотвращает регрессии

### 📈 Желательно
**Итерация 5:** Интеграционные тесты
- Проверяет полный цикл работы
- Увеличивает coverage до > 80%
- Готовит к CI/CD

---

## Полезные команды

### Проверка качества
```bash
# Полная проверка
make quality

# Отдельные инструменты
make format      # Автоформатирование
make lint        # Линтер с автофиксом
make typecheck   # Проверка типов
```

### Тестирование
```bash
# Запуск тестов
make test

# Тесты с coverage
make test-cov

# Запуск конкретного теста
uv run pytest tests/test_models.py -v

# Запуск тестов с фильтром
uv run pytest tests/ -k "test_conversation" -v
```

### Разработка
```bash
# Запуск бота
make run

# Установка зависимостей
uv pip install -e ".[dev]"

# Проверка конфигурации
uv run python -c "from src.config import Config; print('OK')"
```

---

**Помни:** 
- Главный принцип - **простота** (KISS)
- **Type hints везде** (mypy strict mode)
- **Согласование перед реализацией**
- **Проверка качества перед коммитом**
- **Подтверждение перед следующей итерацией**
