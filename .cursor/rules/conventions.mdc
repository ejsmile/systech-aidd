---
alwaysApply: true
---
# Правила разработки кода

> **Базовый документ:** @vision.md - полное техническое видение проекта

## Ключевые принципы

### 1. KISS - Keep It Simple, Stupid
- Выбирай максимально простое решение
- Избегай сложных паттернов проектирования
- Не создавай абстракции "на будущее"
- Если решение требует пояснения - оно слишком сложное

### 2. Структура кода
- **1 класс = 1 файл** - строгое правило
- **Type hints везде** - обязательное требование (mypy strict mode)
- Асинхронность: используй `async/await` везде
- Именование: понятные имена классов, методов, переменных (английский язык)

### 3. Что НЕ делаем
- ❌ Сложные DI-контейнеры
- ❌ Микросервисная архитектура
- ❌ Абстракции без явной необходимости
- ❌ Избыточное тестирование на старте

## Технологический стек

### Обязательные библиотеки
- **Python 3.11+** - требуемая версия
- **aiogram 3.x** - для Telegram Bot
- **openai** - для работы с LLM через OpenRouter
- **pydantic** - для валидации данных
- **pydantic-settings** - для конфигурации
- **logging** - встроенный модуль для логирования

### Управление зависимостями
- **uv** - единственный инструмент для управления пакетами и окружением
- `pyproject.toml` - объявление зависимостей
- `uv.lock` - автоматически генерируемый lockfile

## Работа с внешними библиотеками

### Правило официальной документации
При использовании внешних библиотек **ОБЯЗАТЕЛЬНО** сверяйся с официальной документацией:

1. **MCP Context7** (приоритет)
   - Используй `resolve-library-id` для поиска библиотеки
   - Используй `get-library-docs` для получения актуальной документации
   - Примеры: aiogram, pydantic, openai и другие популярные библиотеки

2. **Docs в Cursor** (альтернатива)
   - Если библиотека недоступна через Context7
   - Используй встроенную документацию Cursor

3. **Когда обращаться к документации:**
   - При первом использовании библиотеки
   - При использовании сложных/неочевидных API
   - При миграции между версиями
   - При возникновении ошибок или неожиданного поведения
   - При выборе между несколькими подходами реализации

### Цель
- Использовать актуальные и рекомендуемые практики
- Избегать устаревших паттернов
- Следовать best practices библиотеки
- Предотвращать ошибки из-за неправильного использования API

## Паттерны кода

### Конфигурация
```python
# Всегда через pydantic-settings BaseSettings
from pydantic_settings import BaseSettings

class Config(BaseSettings):
    telegram_token: str
    openrouter_api_key: str
    # ... другие поля
    
    class Config:
        env_file = ".env"
```

### Классы данных
```python
# Для immutable данных - dataclass с frozen=True
from dataclasses import dataclass
from typing import Literal

@dataclass(frozen=True)
class ConversationKey:
    chat_id: int
    user_id: int

# Для изменяемых данных - обычный dataclass с type hints
@dataclass
class ChatMessage:
    role: Literal["system", "user", "assistant"]
    content: str
    
    def to_dict(self) -> dict[str, str]:
        """Конвертация в формат OpenAI API"""
        return {"role": self.role, "content": self.content}
```

### Логирование
```python
# В начале файла
import logging
logger = logging.getLogger(__name__)

# Использование
logger.info("Bot started")
logger.debug(f"User message: {message}")  # только для DEBUG режима
logger.error(f"API error: {error}")
```

### Обработка ошибок
- Валидация конфигурации при старте (fail-fast)
- Graceful degradation: при ошибке LLM бот продолжает работать
- Простые сообщения об ошибках пользователю (без технических деталей)
- Детальное логирование ошибок для разработчика

## Структура файлов

### Правило именования
- `snake_case` для файлов: `llm_client.py`, `conversation.py`
- `PascalCase` для классов: `LLMClient`, `ConversationManager`
- `snake_case` для переменных и методов: `get_response()`, `max_history_messages`

### Организация импортов
```python
# 1. Стандартная библиотека
import logging
from dataclasses import dataclass

# 2. Сторонние библиотеки
from aiogram import Bot, Dispatcher
from pydantic import BaseModel

# 3. Локальные импорты
from .config import Config
from .models import Message
```

## Хранение данных

- **Простые данные** - в оперативной памяти (dict, list)
- **Конфигурация** - через переменные окружения + `.env` файл
- **НЕ используем** базы данных на начальном этапе

## Логирование

### Уровни
- **DEBUG** - содержимое сообщений (только для разработки)
- **INFO** - старт/стоп, команды (без содержимого)
- **ERROR** - ошибки API, сетевые проблемы

### Правила
- Содержимое сообщений пользователей логируется **ТОЛЬКО** в DEBUG режиме
- В INFO и выше - только факты событий без приватных данных
- Уровень задается через переменную окружения `LOG_LEVEL`

## Асинхронность

- Все взаимодействие с внешними API - асинхронное
- Используй `async/await` (требование aiogram)
- Таймауты для внешних запросов (например, 30 сек для LLM)

## Документирование

- Имена классов и методов должны быть самодокументируемыми
- Docstrings только для неочевидной логики
- Комментарии - только для объяснения "почему", а не "что"
- Основная документация - в файлах проекта в `docs/`

## Качество кода

### Инструменты автоматизации
- **ruff** - форматирование и линтинг кода
- **mypy** - проверка типов (strict mode)
- **pytest** - автоматизированное тестирование
- Все инструменты настроены в `pyproject.toml`

### Форматирование
- Длина строки: 100 символов
- Автоформатирование через `ruff format`
- Проверка перед коммитом: `make quality`

### Type Hints

**Обязательное требование:** Все функции, методы и атрибуты классов должны иметь type hints (требование mypy strict mode).

**Специальные типы:**
- `Literal["value1", "value2"]` для ограниченного набора значений
- `Enum` для валидации констант с именами
- Современный синтаксис: `list[str]`, `dict[str, int]` (Python 3.11+)

**Примеры:**
```python
class ConversationManager:
    def __init__(self, max_history_messages: int = 20) -> None:
        self.conversations: dict[ConversationKey, list[ChatMessage]] = {}
        self.max_history_messages: int = max_history_messages
    
    def get_history(self, key: ConversationKey, system_prompt: str) -> list[ChatMessage]:
        ...

async def handle_message(message: Message, bot: Bot) -> None:
    ...

def set_role(role: Literal["user", "assistant", "system"]) -> None:
    ...
```

**Проверка:** `make typecheck`

### Тестирование
- Unit-тесты для критичных компонентов
- Минимум mock'ов - только для внешних API
- Понятные названия тестов (что проверяем, а не как)
- Coverage > 70% для критичных модулей
- Fixtures в `conftest.py` для переиспользования

### Команды проверки качества
```bash
make format      # Автоформатирование кода
make lint        # Проверка линтером
make typecheck   # Проверка типов
make quality     # Все проверки вместе
make test        # Запуск тестов
make test-cov    # Тесты с coverage
```

## Лучшие практики Python

### Модели данных
- `dataclass(frozen=True)` для immutable типов
- `Literal` для строгой типизации строковых констант
- `Enum` для валидации значений
- Избегай конфликтов имен (например, `ChatMessage` вместо `Message`)

### Валидация
- Fail-fast: валидация конфигурации при старте
- Pydantic для проверки данных из внешних источников
- Type hints + mypy для compile-time проверок

### Изоляция тестов
- Каждый тест независим и быстр
- Fixtures для подготовки окружения
- Async тесты с `pytest.mark.asyncio`
- Mock только внешние зависимости (API, сеть)

---

**Помни:** Главный принцип - простота. Если сомневаешься - выбирай более простое решение.

